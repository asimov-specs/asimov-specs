<pre class=metadata>
Title: ASIMOV Module Resolver Specification (MRS)
Shortname: module-resolver
Level: 1
Status: LS
URL: https://asimov-specs.github.io/module-resolver/
Editor: ASIMOV Systems https://asimov.systems
Repository: asimov-specs/asimov-specs
Abstract: This specification defines the ASIMOV Module Resolver, a system for discovering and selecting appropriate modules to handle specific resources based on URL patterns, file extensions, and content types. The resolver uses a finite state automaton approach to efficiently match resource identifiers against module capabilities declared in module manifests.
Markup Shorthands: css no, markdown yes
Ignored Terms: h1, h2, h3, h4, h5, h6, xmp
Default Highlight: rust
</pre>

<pre class=link-defaults>
spec:html; type:element;
    text:a
    text:script
    text:style
    text:title
    text:link
spec:bikeshed-1; type:dfn; for:railroad; text:optional
</pre>

Introduction {#introduction}
============================

## Overview ## {#overview}

The ASIMOV Module Resolver provides a mechanism for automatically selecting appropriate modules to handle specific resources within the ASIMOV Platform. Given a resource identifier (typically a URL), the resolver determines which registered modules are capable of processing that resource based on their declared capabilities in module manifests.

The resolver uses a finite state automaton (FSA) approach for efficient pattern matching, allowing it to handle complex URL patterns, wildcards, and hierarchical matching rules with optimal performance characteristics.

## Scope ## {#scope}

This specification covers:

- The resolver's internal data structures and algorithms
- URL parsing and tokenization rules
- Pattern matching semantics for different resource types
- Conflict resolution when multiple modules can handle the same resource
- Performance characteristics and optimization strategies

This specification does not cover:

- The format of module manifests (covered in [[MODULE-MANIFEST]])
- Runtime module execution or communication protocols
- Platform-specific integration details

## Conformance ## {#spec-conformance}

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[RFC2119]].

A conforming resolver implementation is one that correctly implements the algorithms and behaviors defined in this specification.

Resolver Architecture {#architecture}
=====================================

## Core Components ## {#core-components}

The resolver consists of several key components:

### Resolver State Machine ### {#state-machine}

The resolver maintains a finite state automaton where:
- **States** represent decision points in the resource matching process
- **Transitions** represent URL path segments, domains, protocols, or other resource components
- **Final States** contain sets of modules that can handle resources matching the path to that state

### Module Registry ### {#module-registry}

The resolver maintains a registry of known modules, indexed by:
- Module names for quick lookup
- File extensions for file-based resource handling
- Reference-counted module instances to optimize memory usage

### URL Tokenizer ### {#url-tokenizer}

The resolver includes a URL tokenizer that breaks down resource identifiers into structured components that can be matched against module capabilities.

## Data Structures ## {#data-structures}

### Section Types ### {#section-types}

The resolver processes URLs by breaking them into typed sections:

<table class="data">
  <thead>
    <tr>
      <th>Section Type</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><dfn>Protocol</dfn></td>
      <td>URL scheme identifier</td>
      <td><code>https</code>, <code>file</code>, <code>near</code></td>
    </tr>
    <tr>
      <td><dfn>Domain</dfn></td>
      <td>Domain name component (reversed)</td>
      <td><code>com</code>, <code>google</code>, <code>www</code></td>
    </tr>
    <tr>
      <td><dfn>WildcardDomain</dfn></td>
      <td>Matches any domain component</td>
      <td><code>*</code> in patterns</td>
    </tr>
    <tr>
      <td><dfn>Path</dfn></td>
      <td>URL path segment</td>
      <td><code>search</code>, <code>api</code>, <code>v1</code></td>
    </tr>
    <tr>
      <td><dfn>WildcardPath</dfn></td>
      <td>Matches any path segment</td>
      <td><code>:id</code>, <code>:account</code></td>
    </tr>
    <tr>
      <td><dfn>QueryParamName</dfn></td>
      <td>Query parameter name</td>
      <td><code>q</code>, <code>v</code>, <code>lang</code></td>
    </tr>
    <tr>
      <td><dfn>QueryParamValue</dfn></td>
      <td>Query parameter value</td>
      <td><code>search+terms</code>, <code>en</code></td>
    </tr>
    <tr>
      <td><dfn>WildcardQueryParamValue</dfn></td>
      <td>Matches any parameter value</td>
      <td><code>:query</code>, <code>:video_id</code></td>
    </tr>
    <tr>
      <td><dfn>Any</dfn></td>
      <td>Matches any section type</td>
      <td>Used for prefix matching</td>
    </tr>
  </tbody>
</table>

### Node Structure ### {#node-structure}

Each node in the resolver's finite state automaton contains:

- **transitions**: A mapping from section types to next state indices
- **modules**: A set of modules that can handle resources reaching this state

URL Processing {#url-processing}
================================

## Tokenization Algorithm ## {#tokenization}

The resolver tokenizes URLs using the following algorithm:

1. **Empty URL Check**: Return error if URL is empty
2. **Protocol Extraction**: If URL contains no colon, treat entire string as protocol
3. **URL Parsing**: Parse as standard URL using [[RFC3986]]
4. **Protocol Section**: Add protocol as first section
5. **Domain Processing**:
   - Split domain by dots and reverse order
   - Remove leading "www" for HTTP/HTTPS protocols
   - Add each domain component as Domain section
6. **Path Processing**:
   - For non-base URLs, add entire path as single Path section
   - For base URLs, split path by "/" and add non-empty segments
7. **Query Processing**: Add query parameters as ParamName/ParamValue pairs

### Domain Reversal ### {#domain-reversal}

Domain components are processed in reverse order to enable efficient hierarchical matching. For example, `api.google.com` becomes the sequence: `[com, google, api]`.

This allows the resolver to match from most general (top-level domain) to most specific (subdomain) components.

### WWW Prefix Handling ### {#www-handling}

For HTTP and HTTPS URLs, the resolver automatically strips the "www" prefix to normalize URLs. This ensures that `www.example.com` and `example.com` are treated equivalently.

## Pattern Matching ## {#pattern-matching}

### Wildcard Transformation ### {#wildcard-transformation}

When processing URL patterns from module manifests, certain sections are transformed into wildcard types:

- Domain sections containing "*" become WildcardDomain
- Path sections starting with ":" become WildcardPath
- Query parameter values starting with ":" become WildcardQueryParamValue

### Matching Rules ### {#matching-rules}

Section matching follows these rules:

1. **Exact Match**: Sections match if they are identical
2. **Wildcard Match**: Wildcard sections match corresponding concrete sections:
   - WildcardDomain matches any Domain
   - WildcardPath matches any Path
   - WildcardQueryParamValue matches any QueryParamValue
3. **Any Match**: The Any section type matches any other section type
4. **No Match**: All other combinations do not match

Module Registration {#registration}
===================================

## Registration Methods ## {#registration-methods}

The resolver provides several methods for registering module capabilities:

### Protocol Registration ### {#protocol-registration}

```rust
pub fn insert_protocol(&mut self, module: &str, protocol: &str) -> Result<(), Box<dyn Error>>
```

Registers a module to handle all URLs with the specified protocol scheme. The implementation:

1. Creates a state for the protocol section
2. Adds a self-loop (Any â†’ self) to handle all subsequent URL components
3. Associates the module with the protocol state

### Prefix Registration ### {#prefix-registration}

```rust
pub fn insert_prefix(&mut self, module: &str, prefix: &str) -> Result<(), Box<dyn Error>>
```

Registers a module to handle URLs starting with the specified prefix. The implementation:

1. Tokenizes the prefix URL
2. Creates states for each component in the prefix
3. Adds a self-loop at the final state to match extensions of the prefix
4. Associates the module with the final state

### Pattern Registration ### {#pattern-registration}

```rust
pub fn insert_pattern(&mut self, module: &str, pattern: &str) -> Result<(), Box<dyn Error>>
```

Registers a module to handle URLs matching the specified pattern. The implementation:

1. Tokenizes the pattern URL
2. Transforms pattern sections into wildcards
3. Creates states for each component
4. Associates the module with the final state (no self-loop)

### File Extension Registration ### {#file-extension-registration}

```rust
pub fn insert_file_extension(&mut self, module: &str, extension: &str) -> Result<(), Box<dyn Error>>
```

Registers a module to handle files with the specified extension. File extension matching is handled separately from the main FSA for efficiency.

## State Management ## {#state-management}

### Node Creation ### {#node-creation}

The resolver creates FSA nodes on-demand during registration:

1. **Root Node Lookup**: Find or create root node for the first URL component
2. **Path Traversal**: For each subsequent component:
   - Check if transition exists from current node
   - If not, create new node and add transition
   - Handle special cases (e.g., WildcardDomain self-loops)
3. **Module Association**: Add module to the final node's module set

### Memory Management ### {#memory-management}

The resolver uses reference counting for modules to optimize memory usage:
- Modules are stored as `Rc<Module>` (reference-counted smart pointers)
- Multiple nodes can reference the same module instance
- Modules are automatically deallocated when no longer referenced

Resolution Algorithm {#resolution}
==================================

## Resolution Process ## {#resolution-process}

The resolver processes resource identifiers using this algorithm:

```rust
pub fn resolve(&self, url: &str) -> Result<Vec<Rc<Module>>, Box<dyn Error>>
```

1. **Tokenization**: Break URL into typed sections
2. **File Extension Check**: For file:// URLs, check file extension registry
3. **Root State Initialization**: Find all root states matching the first section
4. **State Traversal**: For each remaining section:
   - Find all possible transitions from current states
   - Collect reachable next states
   - Continue with non-empty state set
5. **Module Collection**: Gather all modules from final states
6. **Deduplication**: Return unique set of matching modules

### Parallel State Tracking ### {#parallel-states}

The resolver maintains multiple active states simultaneously during resolution, allowing it to handle ambiguous matches and find all possible module candidates.

## Conflict Resolution ## {#conflict-resolution}

When multiple modules can handle the same resource, the resolver applies these precedence rules:

1. **Specificity**: More specific patterns take precedence over less specific ones
2. **Pattern Types**: In order of precedence:
   - Exact patterns (no wildcards)
   - Wildcard patterns
   - Prefix patterns
   - Protocol patterns
3. **Registration Order**: For equal specificity, registration order may be used as a tiebreaker

### File Extension Priority ### {#file-extension-priority}

File extension matching takes precedence over URL-based matching for `file://` URLs. This ensures that file type handlers are selected based on actual file content rather than URL structure.

Performance Characteristics {#performance}
==========================================

## Time Complexity ## {#time-complexity}

The resolver provides the following performance characteristics:

- **Registration**: O(|P|) where |P| is the length of the URL pattern
- **Resolution**: O(|U| Ã— |S|) where |U| is the URL length and |S| is the average number of active states
- **Memory**: O(|M| Ã— |P|) where |M| is the number of modules and |P| is the average pattern length

## Space Optimization ## {#space-optimization}

The resolver optimizes memory usage through:

1. **Shared Modules**: Reference counting prevents module duplication
2. **Compact Representations**: URLs are tokenized into structured sections
3. **Efficient Collections**: BTreeMap and BTreeSet for ordered, memory-efficient storage

## Scalability Considerations ## {#scalability}

The resolver is designed to handle:
- Thousands of registered modules
- Complex URL patterns with multiple wildcards
- High-frequency resolution requests
- Concurrent access patterns (implementation-dependent)

Error Handling {#error-handling}
================================

## Error Types ## {#error-types}

The resolver defines these error conditions:

### URL Parsing Errors ### {#url-parsing-errors}

- Empty URLs
- Malformed URL syntax
- Unsupported URL schemes (implementation-dependent)

### Registration Errors ### {#registration-errors}

- Invalid module names
- Malformed URL patterns
- Resource exhaustion

### Resolution Errors ### {#resolution-errors}

- URL parsing failures
- Internal state inconsistencies

## Error Recovery ## {#error-recovery}

The resolver implements graceful error handling:

1. **Validation**: Input validation at registration time
2. **Isolation**: Errors in one module don't affect others
3. **Fallback**: Partial matches may be returned when possible
4. **Logging**: Detailed error information for debugging

Security Considerations {#security}
===================================

## Input Validation ## {#input-validation}

Implementations MUST validate all inputs to prevent:

- **URL Injection**: Malicious URLs that could exploit parsing logic
- **Pattern Injection**: Malicious patterns that could cause denial of service
- **Resource Exhaustion**: Patterns that could consume excessive memory or CPU

## Regular Expression Safety ## {#regex-safety}

While this specification doesn't mandate regular expressions, implementations using them MUST protect against:

- **ReDoS Attacks**: Regular expression denial of service
- **Catastrophic Backtracking**: Exponential time complexity in pattern matching
- **Memory Exhaustion**: Unbounded memory allocation during matching

## Access Control ## {#access-control}

The resolver itself doesn't implement access control, but implementations SHOULD:

- Validate module registration permissions
- Audit resolution requests for sensitive resources
- Implement rate limiting for resolution requests

IANA Considerations {#iana}
===========================

This specification does not require any IANA registrations.

Implementation Notes {#implementation}
=====================================

## Reference Implementation ## {#reference-implementation}

The reference implementation is written in Rust and provides:

- Memory-safe module management
- Efficient pattern matching using finite state automata
- Comprehensive test coverage
- Integration with the ASIMOV module manifest system

## Alternative Implementations ## {#alternative-implementations}

Implementations in other languages SHOULD maintain the same algorithmic behavior while adapting to language-specific idioms and performance characteristics.

## Testing Requirements ## {#testing-requirements}

Conforming implementations MUST pass test cases covering:

- Basic URL tokenization and parsing
- Pattern matching with wildcards
- Conflict resolution between overlapping patterns
- File extension handling
- Error conditions and edge cases

Examples {#examples}
===================

## Basic Usage ## {#basic-usage}

```rust
use resolver::Resolver;

let mut resolver = Resolver::new();

// Register modules
resolver.insert_protocol("near", "near")?;
resolver.insert_pattern("near-account", "near://account/:id")?;
resolver.insert_pattern("near-tx", "near://tx/:id")?;
resolver.insert_prefix("google", "https://google.com/search?q=")?;

// Resolve URLs
let modules = resolver.resolve("near://account/alice.near")?;
assert_eq!(modules[0].name, "near-account");

let modules = resolver.resolve("https://google.com/search?q=rust")?;
assert_eq!(modules[0].name, "google");
```

## Complex Pattern Matching ## {#complex-patterns}

```rust
// Wildcard domain matching
resolver.insert_pattern("linkedin", "https://*.linkedin.com/in/:account/test")?;

// Multiple subdomain matching
let modules = resolver.resolve("https://www.linkedin.com/in/johndoe/test")?;
assert!(modules.iter().any(|m| m.name == "linkedin"));

let modules = resolver.resolve("https://api.linkedin.com/in/johndoe/test")?;
assert!(modules.iter().any(|m| m.name == "linkedin"));
```

## File Extension Handling ## {#file-extension-examples}

```rust
// Register file handlers
resolver.insert_file_extension("txt-handler", "txt")?;
resolver.insert_file_extension("archive-handler", "tar.gz")?;

// Resolve file URLs
let modules = resolver.resolve("file:///path/to/document.txt")?;
assert!(modules.iter().any(|m| m.name == "txt-handler"));

let modules = resolver.resolve("file:///path/to/archive.tar.gz")?;
assert!(modules.iter().any(|m| m.name == "archive-handler"));
```

## Conflict Resolution Example ## {#conflict-example}

```rust
// Register overlapping patterns
resolver.insert_protocol("http-generic", "https")?;
resolver.insert_prefix("google-prefix", "https://google.com/")?;
resolver.insert_pattern("google-search", "https://google.com/search?q=:query")?;

// Most specific pattern wins
let modules = resolver.resolve("https://google.com/search?q=rust")?;
assert_eq!(modules[0].name, "google-search");

// Prefix matches when pattern doesn't
let modules = resolver.resolve("https://google.com/maps")?;
assert_eq!(modules[0].name, "google-prefix");
```

References {#spec-references}
========================

## Normative References ## {#spec-normative}

<dl>
  <dt id="RFC2119">[[RFC2119]]
  <dd>S. Bradner. <a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>. March 1997. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a>

  <dt id="RFC3986">[[RFC3986]]
  <dd>T. Berners-Lee; R. Fielding; L. Masinter. <a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>. January 2005. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc3986">https://tools.ietf.org/html/rfc3986</a>

  <dt id="MODULE-MANIFEST">[[MODULE-MANIFEST]]
  <dd>ASIMOV Systems. <a href="https://asimov-specs.github.io/module-manifest/">ASIMOV Module Manifest Specification</a>. URL: <a href="https://asimov-specs.github.io/module-manifest/">https://asimov-specs.github.io/module-manifest/</a>
</dl>

## Informative References ## {#spec-informative}

<dl>
  <dt id="ASIMOV">ASIMOV
  <dd>ASIMOV Systems. <a href="https://asimov.systems">ASIMOV Platform Documentation</a>. URL: <a href="https://asimov.systems">https://asimov.systems</a>
</dl>

Acknowledgments {#acknowledgments}
==================================

The editors would like to thank the ASIMOV Platform community for their contributions and feedback during the development of this specification.

Changes {#changes}
==================

This section will document changes between versions of this specification.

## Version 1.0 ## {#v1}

Initial version of the ASIMOV Module Resolver Specification.
